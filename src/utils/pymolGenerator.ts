export interface PyMOLGenOptions {
    distanceData: {
        matrix: number[][];
        labels: { resNo: number; chain: string; label: string }[];
    };
    filters: {
        all: boolean;
        hydrophobic: boolean;
        saltBridge: boolean;
        piStacking: boolean;
        disulfide: boolean;
    };
    thresholds: {
        contact: number;
        proximal: number;
    };
    showIntraChain: boolean;
}

const getInteractionType = (label1: string, label2: string, dist: number) => {
    // Helper must mimic the main ContactMap logic to match filters accurately
    const getResName = (l: string) => l.trim().split(' ')[0].toUpperCase();
    const r1 = getResName(label1);
    const r2 = getResName(label2);

    const POSITIVE = ['ARG', 'LYS', 'HIS'];
    const NEGATIVE = ['ASP', 'GLU'];
    const AROMATIC = ['PHE', 'TYR', 'TRP', 'HIS'];
    const HYDROPHOBIC = ['ALA', 'VAL', 'ILE', 'LEU', 'MET', 'PHE', 'TYR', 'TRP', 'CYS', 'PRO'];

    if (r1 === 'CYS' && r2 === 'CYS' && dist < 3.0) return 'disulfide';

    const isP1 = POSITIVE.includes(r1);
    const isN1 = NEGATIVE.includes(r1);
    const isP2 = POSITIVE.includes(r2);
    const isN2 = NEGATIVE.includes(r2);
    if ((isP1 && isN2) || (isN1 && isP2)) return 'saltBridge';

    const isA1 = AROMATIC.includes(r1);
    const isA2 = AROMATIC.includes(r2);
    if ((isP1 && isA2) || (isA1 && isP2)) return 'cationPi'; // Mapped to piStacking for simple filter
    if (isA1 && isA2) return 'piStacking';

    const isH1 = HYDROPHOBIC.includes(r1);
    const isH2 = HYDROPHOBIC.includes(r2);
    if (isH1 && isH2 && dist < 5.0) return 'hydrophobic';

    return 'other';
};

export const generatePyMOLScript = (options: PyMOLGenOptions): string => {
    const { distanceData, filters, thresholds, showIntraChain } = options;
    const { matrix, labels } = distanceData;

    let script = `# PyMOL Script generated by Quercus Protein Viewer\n`;
    script += `# Usage: File -> Run Script... in PyMOL\n\n`;

    script += `# 1. Setup View\n`;
    script += `bg_color white\n`;
    script += `hide all\n`;
    script += `show cartoon\n`;
    script += `color white, all\n\n`;
    script += `# Highlight Chains\n`;
    script += `util.cbc\n\n`; // Determine colors by chain

    script += `# 2. Define Selections & Contacts\n`;

    const addedContacts = new Set<string>();

    for (let i = 0; i < matrix.length; i++) {
        for (let j = i + 1; j < matrix[i].length; j++) {
            const dist = matrix[i][j];

            // 1. Threshold Check
            if (dist > thresholds.proximal) continue;

            const resA = labels[i];
            const resB = labels[j];

            // 2. Intra-Chain Check
            if (!showIntraChain && resA.chain === resB.chain) continue;

            // 3. Filter Logic
            let shouldShow = false;
            let groupName = "contact";
            let color = "grey80";

            const type = getInteractionType(resA.label, resB.label, dist);

            if (filters.all) {
                // Determine color by type even if "All" is checked
                if (type === 'saltBridge') { color = "red"; groupName = "salt_bridges"; }
                else if (type === 'disulfide') { color = "yellow"; groupName = "disulfides"; }
                else if (type === 'hydrophobic') { color = "green"; groupName = "hydrophobic"; }
                else if (type === 'piStacking' || type === 'cationPi') { color = "magenta"; groupName = "pi_stacking"; }
                else if (dist < thresholds.contact) { color = "blue"; groupName = "close_contacts"; }
                else { color = "lightblue"; groupName = "proximal_contacts"; }

                shouldShow = true;
            } else {
                // Strict Filtering
                if (filters.saltBridge && type === 'saltBridge') { shouldShow = true; color = "red"; groupName = "salt_bridges"; }
                else if (filters.disulfide && type === 'disulfide') { shouldShow = true; color = "yellow"; groupName = "disulfides"; }
                else if (filters.hydrophobic && type === 'hydrophobic') { shouldShow = true; color = "green"; groupName = "hydrophobic"; }
                else if (filters.piStacking && (type === 'piStacking' || type === 'cationPi')) { shouldShow = true; color = "magenta"; groupName = "pi_stacking"; }
            }

            if (shouldShow) {
                const id = `dist_${resA.chain}${resA.resNo}_${resB.chain}${resB.resNo}`;
                if (!addedContacts.has(id)) {
                    // PyMOL Selection: chain X and resi Y and name CA
                    // Using CA for safe backbone distance, or generic residue selection
                    script += `distance ${id}, (chain ${resA.chain} and resi ${resA.resNo} and name CA), (chain ${resB.chain} and resi ${resB.resNo} and name CA)\n`;
                    script += `color ${color}, ${id}\n`;

                    // Grouping for tidiness
                    script += `group ${groupName}, ${id}\n`;
                    addedContacts.add(id);
                }
            }
        }
    }

    script += `\n# 3. Final Polish\n`;
    script += `hide labels\n`;
    script += `set dash_gap, 0.2\n`;
    script += `set dash_radius, 0.05\n`;
    script += `zoom visible\n`;

    return script;
};
